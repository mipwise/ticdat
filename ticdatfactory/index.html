<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>TicDatFactory - Ticdat</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "TicDatFactory";
    var mkdocs_page_input_path = "ticdatfactory.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Ticdat</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">pandatfactory.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../pandatfactory/">PanDatFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">pandatio.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../pandatio/">CsvPanFactory</a>
                </li>
                <li class="">
                    
    <a class="" href="../pandatio/">JsonPanFactory</a>
                </li>
                <li class="">
                    
    <a class="" href="../pandatio/">SqlPanFactory</a>
                </li>
                <li class="">
                    
    <a class="" href="../pandatio/">XlsPanFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">ticdatfactory.py</span>
    <ul class="subnav">
                <li class=" current">
                    
    <a class="current" href="./">TicDatFactory</a>
    <ul class="subnav">
            
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">csvtd.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../csvtd/">CsvTicFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">jsontd.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../jsontd/">JsonTicFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">mdb.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../mdb/">MdbTicFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">pgtd.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../pgtd/">PostgresPanFactory</a>
                </li>
                <li class="">
                    
    <a class="" href="../pgtd/">PostgresTicFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">sqlitetd.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../sqlitetd/">SQLiteTicFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">xls.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../xls/">XlsTicFactory</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">utils.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../utils/">Utilities</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">model.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../model/">Model</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">opl.py</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../opl/">OPL</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Ticdat</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>ticdatfactory.py &raquo;</li>
        
      
    
    <li>TicDatFactory</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/ticdat/ticdat/edit/master/docs/ticdatfactory.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="ticdat.ticdatfactory.TicDatFactory">TicDatFactory</h1>

<pre><code class="python">TicDatFactory(self, **init_fields)
</code></pre>

<p>Primary class for ticdat library. This class is constructed with a schema.
It can be used to generate TicDat objects, to write TicDat objects to
different file types, or to perform bulk query operations to diagnose
common data integrity failures.</p>
<p>Analytical code that uses TicDat objects can be used, without change, on different data
sources, thus facilitating the "separate model from data" design goal.</p>
<p>:param init_fields: a mapping of tables to primary key fields and data fields. Each field listing consists
                    of two sub lists ... first primary keys fields, than data fields.</p>
<p>ex:
<code>TicDatFactory (categories =  [["name"],["minNutrition", "maxNutrition"]],
                   foods  =  [["name"],["cost"]]
                   nutritionQuantities = [["food", "category"],["qty"]])</code></p>
<p>Use '*' instead of a pair of lists for generic tables,
                   which will render as pandas.DataFrame objects.</p>
<p>ex:
<code>TicDatFactory (typical_table = [["primary key field"],["data field"]],
                   generic_table = '*')</code></p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.add_parameter">add_parameter</h1>

<pre><code class="python">TicDatFactory.add_parameter(self, name, default_value, number_allowed=True, inclusive_min=True, inclusive_max=False, min=0, max=inf, must_be_int=False, strings_allowed=(), nullable=False, datetime=False, enforce_type_rules=True)
</code></pre>

<p>Add (or reset) a parameters option. Requires that a parameters table with one primary key field and one
data field already be present. The legal parameters options will be enforced as part of find_data_row_failures
Note that if you are using this function, then you would typically read from the parameters table indirectly,
by using the dictionary returned by create_full_parameters_dict.</p>
<p>:param name: name of the parameter to add or reset</p>
<p>:param default_value: default value for the parameter (used for create_full_parameters_dict)</p>
<p>:param number_allowed: boolean does this parameter allow numbers?</p>
<p>:param inclusive_min: if number allowed, is the min inclusive?</p>
<p>:param inclusive_max: if number allowed, is the max inclusive?</p>
<p>:param min: if number allowed, the minimum value</p>
<p>:param max: if number allowed, the maximum value</p>
<p>:param must_be_int: boolean : if number allowed, must the number be integral?</p>
<p>:param strings_allowed: if a collection - then a list of the strings allowed.
                        The empty collection prohibits strings.
                        If a "*", then any string is accepted.</p>
<p>:param nullable:  boolean : can this parameter be set to null (aka None)</p>
<p>:param datetime: If truthy, then number_allowed through strings_allowed are ignored.
                 Should the data either be a datetime.datetime object or a string that can be parsed into a
                 datetime.datetime object?</p>
<p>:param enforce_type_rules: boolean: ignore all of number_allowed through nullable, and only
                           enforce the parameter names and default values
:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.add_data_row_predicate">add_data_row_predicate</h1>

<pre><code class="python">TicDatFactory.add_data_row_predicate(self, table, predicate, predicate_name=None, predicate_kwargs_maker=None, predicate_failure_response='Boolean')
</code></pre>

<p>The purpose of calling add_data_row_predicate is to prepare for a future call to find_data_row_failures.
See https://bit.ly/3e9pdCP for more details on these two functions.</p>
<p>Adds a data row predicate for a table. Row predicates can be used to check for
sophisticated data integrity problems of the sort that can't be easily handled with
a data type rule. For example, a min_supply column can be verified to be no larger than
a max_supply column.</p>
<p>:param table: table in the schema</p>
<p>:param predicate: A one argument function that accepts a table row as an argument and returns
                  Truthy if the row is valid and Falsey otherwise. (See below, there are other arguments that
                  can refine how predicate works). The row argument passed to predicate will be a dict that
                  maps field name to data value for all fields (both primary key and data field) in the table.
                  Note - if None is passed as a predicate, then any previously added
                  predicate matching (table, predicate_name) will be removed.</p>
<p>:param predicate_name: The name of the predicate. If omitted, the smallest non-colliding
                       number will be used.</p>
<p>:param predicate_kwargs_maker: A function used to support predicate if predicate accepts more than just
                               the row argument. This function accepts a single dat argument and is called
                               exactly once per find_data_row_failures call. If predicate_kwargs_maker returns a
                               dict, then this dict is unpacked for each call to predicate. An error (or a bulk
                               row failure) results if predicate_kwargs_maker fails to return a dict.</p>
<p>:param predicate_failure_response: Either "Boolean" or "Error Message". If the latter then predicate indicates
                                   a clean row by returning True (the one and only literal True in Python)
                                   and a dirty row by returning a non-empty string (which is an error message).</p>
<p>See find_data_row_failures for details on handling exceptions thrown by predicate or predicate_kwargs_maker.
:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.add_foreign_key">add_foreign_key</h1>

<pre><code class="python">TicDatFactory.add_foreign_key(self, native_table, foreign_table, mappings)
</code></pre>

<p>Adds a foreign key relationship to the schema.  Adding a foreign key doesn't block
the entry of child records that fail to find a parent match. It does make it easy
to recognize such records (with find_foreign_key_failures()) and to remove such records
(with remove_foreign_key_failures())</p>
<p>:param native_table: (aka child table). The table with fields that must match some other table.</p>
<p>:param foreign_table: (aka parent table). The table providing the matching entries.</p>
<p>:param mappings: For simple foreign keys, a [native_field, foreign_field] pair.
                 For compound foreign keys an iterable of [native_field, foreign_field]
                 pairs.</p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.clear_data_type">clear_data_type</h1>

<pre><code class="python">TicDatFactory.clear_data_type(self, table, field)
</code></pre>

<p>clears the data type for a field. By default, fields don't have types.  Adding a data type doesn't block
data of the wrong type from being entered. Data types are useful for recognizing errant data entries.
If no data type is specified (the default) then no errant data will be recognized.</p>
<p>:param table: table in the schema</p>
<p>:param field:</p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.clear_foreign_keys">clear_foreign_keys</h1>

<pre><code class="python">TicDatFactory.clear_foreign_keys(self, native_table=None)
</code></pre>

<p>create a TicDatFactory</p>
<p>:param native_table: optional. The table whose foreign keys should be cleared.
                     If omitted, all foreign keys are cleared.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.clone">clone</h1>

<pre><code class="python">TicDatFactory.clone(self, table_restrictions=None, clone_factory=None)
</code></pre>

<p>clones the TicDatFactory</p>
<p>:param table_restrictions : if None, then argument is ignored. Otherwise, a container listing the
                            tables to keep in the clone. Tables outside table_restrictions are removed from
                            the clone.</p>
<p>:param clone_factory : optional. Defaults to TicDatFactory. Can also be PanDatFactory. Can also be a function,
                       in which case it should behave similarly to create_from_full_schema.
                       If clone_factory=PanDatFactory, the row predicates that use predicate_kwargs_maker
                       won't be copied over.</p>
<p>:return: a clone of the TicDatFactory. Returned object will based on clone_factory, if provided.</p>
<p>Note - If you want to remove tables via a clone, then call like this
       tdf_new = tdf.clone(table_restrictions=set(tdf.all_tables).difference(tables_to_remove))
       Other schema editing operations are available with clone_add_a_table, clone_add_a_column,
       clone_remove_a_column and clone_rename_a_column.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.copy_from_ampl_variables">copy_from_ampl_variables</h1>

<pre><code class="python">TicDatFactory.copy_from_ampl_variables(self, ampl_variables)
</code></pre>

<p>copies the solution results from ampl_variables into a new ticdat object</p>
<p>:param ampl_variables: a dict mapping from (table_name, field_name) -&gt; amplpy.variable.Variable
                       (amplpy.variable.Variable is the type object returned by
                        AMPL.getVariable)
                        table_name should refer to a table in the schema that has
                        primary key fields.
                        field_name can refer to a data field for table_name, or it
                        can be falsey. If the latter, then AMPL variables that
                        pass the filter (see below) will simply populate the primary key
                        of the table_name.
                        Note that by default, only non-zero data is copied over.
                        If you want to override this filter, then instead of mapping to
                        amplpy.variable.Variable you should map to a
                        (amplpy.variable.Variable, filter) where filter accepts a data value
                        and returns a boolean.</p>
<p>:return: a deep copy of the ampl_variables into a ticdat object</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.copy_tic_dat">copy_tic_dat</h1>

<pre><code class="python">TicDatFactory.copy_tic_dat(self, tic_dat, freeze_it=False)
</code></pre>

<p>copies the tic_dat object into a new tic_dat object
performs a deep copy</p>
<p>:param tic_dat: a ticdat object</p>
<p>:param freeze_it: boolean. should the returned object be frozen?</p>
<p>:return: a deep copy of the tic_dat argument</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.copy_to_ampl">copy_to_ampl</h1>

<pre><code class="python">TicDatFactory.copy_to_ampl(self, tic_dat, field_renamings=None, excluded_tables=None)
</code></pre>

<p>copies the tic_dat object into a new tic_dat object populated with amplpy.DataFrame objects
performs a deep copy</p>
<p>:param tic_dat: a ticdat object</p>
<p>:param field_renamings: dict or None. If fields are to be renamed in the copy, then
                        a mapping from (table_name, field_name) -&gt; new_field_name
                        If a data field is to be omitted, then new_field can be falsey
                        table_name cannot refer to an excluded table. (see below)</p>
<p>:param excluded_tables: If truthy, a list of tables to be excluded from the copy.
                        Tables without primary key fields are always excluded.</p>
<p>:return: a deep copy of the tic_dat argument into amplpy.DataFrames</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.copy_to_pandas">copy_to_pandas</h1>

<pre><code class="python">TicDatFactory.copy_to_pandas(self, tic_dat, table_restrictions=None, drop_pk_columns=None, reset_index=False)
</code></pre>

<p>copies the tic_dat object into a new object populated with pandas.DataFrame objects
performs a deep copy</p>
<p>:param tic_dat: a ticdat object</p>
<p>:param table_restrictions: If truthy, a list of tables to turn into
                           data frames. Defaults to all tables.</p>
<p>:param drop_pk_columns: boolean or None. should the primary key columns be dropped
                        from the data frames after they have been incorporated
                        into the index.
                        If None, then pk fields will be dropped only for tables with data fields
:param reset_index: boolean. If true, then drop_pk_columns is ignored and the returned DataFrames have
                             a simple integer index with both primary key and data fields as columns.</p>
<p>:return: a deep copy of the tic_dat argument into DataFrames
         To get a valid pan_object object, either set drop_pk_columns to False or set reset_index to True.
         I.e.
            copy_1 = tdf.copy_to_pandas(dat, drop_pk_columns=False)
            copy_2 = tdf.copy_to_pandas(dat, reset_index=True)
            assert all(PanDatFactory(**tdf.schema()).good_pan_dat_object(_) for _ in [copy_1, copy_2])</p>
<pre><code>    Note that None will be converted to nan in the returned object (as is the norm for pandas.DataFrame)
</code></pre>
<h1 id="ticdat.ticdatfactory.TicDatFactory.create_from_full_schema">create_from_full_schema</h1>

<pre><code class="python">TicDatFactory.create_from_full_schema(full_schema)
</code></pre>

<p>create a TicDatFactory complete with default values, data types, and foreign keys</p>
<p>:param full_schema: a dictionary consistent with the data returned by a call to schema()
                    with include_ancillary_info = True</p>
<p>:return: a TicDatFactory reflecting the tables, fields, default values, data types,
         and foreign keys consistent with the full_schema argument</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.create_full_parameters_dict">create_full_parameters_dict</h1>

<pre><code class="python">TicDatFactory.create_full_parameters_dict(self, dat)
</code></pre>

<p>create a fully populated dictionary of all the parameters</p>
<p>:param dat: a TicDat object that has a parameters table</p>
<p>:return: a dictionary that maps parameter option to actual dat.parameters value.
         if the specific option isn't part of dat.parameters, then the default value is used.
         Note that for datetime parameters, the default will be coerced into a datetime object, if possible.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.enable_foreign_key_links">enable_foreign_key_links</h1>

<pre><code class="python">TicDatFactory.enable_foreign_key_links(self)
</code></pre>

<p>call to enable foreign key links. For ex. a TicDat object made from
a factory with foreign key enabled will pass the following assert
assert (dat.foods["chicken"].nutritionQuantities["protein"] is
        dat.categories["protein"].nutritionQuantities["chicken"] is
        dat.nutritionQuantities["chicken", "protein"])
Note that by default, TicDatFactories don't create foreign key links since doing so
can slow down TicDat creation.</p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.find_data_row_failures">find_data_row_failures</h1>

<pre><code class="python">TicDatFactory.find_data_row_failures(self, tic_dat, exception_handling='__debug__', max_failures=inf)
</code></pre>

<p>Finds the data row failures for a ticdat object</p>
<p>:param tic_dat: ticdat object</p>
<p>:param exception_handling: One of "Handled as Failure",  "Unhandled" or "<strong>debug</strong>"
      "Handled as Failure": Any exception generated by calling a row predicate function will indicate a data
                            failure for that row. (Similarly, predicate_kwargs_maker exceptions create an entry
                            in the returned failure dictionary).
      "Unhandled": Exceptions resulting from calling a row predicate (or a predicate_kwargs_maker) will not be
                   handled by data_row_failures.
      "<strong>debug</strong>": Since "Handled as Failure" makes more sense for production runs and "Unhandled" makes more
                   sense for debugging, this option will use the latter if <strong>debug</strong> is True and the former
                   otherwise. See -o and <strong>debug</strong> in Python documentation for more details.</p>
<p>:param max_failures: number. An upper limit on the number of failures to find. Will short circuit and return
                             ASAP with a partial failure enumeration when this number is reached.</p>
<p>:return: A dictionary constructed as follow:</p>
<p>The keys are namedtuples with members "table", "predicate_name".</p>
<p>The values of the returned dictionary are tuples indicating which rows
 failed the predicate test. For tables with a primary key this tuple will
 contain the primary key value of each failed row. Otherwise, this tuple
 will list the positions of the failed rows.</p>
<p>If the predicate_failure_response for the predicate is "Error Message" (instead of "Boolean") then
 the values of the returned dict will themselves be namedtuples with members "primary_key" and "error_message".</p>
<p>If a predicate_kwargs_maker is provided and it fails (either by failing to return a dictionary or by
 throwing a handled exception) then a similar namedtuple is entered as the value, with primary_key='*'
 and error_message as a string.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.find_data_type_failures">find_data_type_failures</h1>

<pre><code class="python">TicDatFactory.find_data_type_failures(self, tic_dat, max_failures=inf)
</code></pre>

<p>Finds the data type failures for a ticdat object</p>
<p>:param tic_dat: ticdat object</p>
<p>:param max_failures: number. An upper limit on the number of failures to find. Will short circuit and return
                             ASAP with a partial failure enumeration when this number is reached.</p>
<p>:return: A dictionary constructed as follow:</p>
<p>The keys are namedtuples with members "table", "field". Each (table,field) pair
 has data values that are inconsistent with its data type. (table, field) pairs
 with no data type at all are never part of the returned dictionary.</p>
<p>The values of the returned dictionary are namedtuples with the following attributes.</p>
<p>--&gt; bad_values - the distinct values for the (table, field) pair that are inconsistent
                  with the data type for (table, field).</p>
<p>--&gt; pks - the distinct primary key entries of the table containing the bad_values
           data. (will be row index for tables with no primary key)</p>
<p>That is to say, bad_values tells you which values in field are failing the data type check,
 and pks tells you which table rows will have their field entry changed if you call
 replace_data_type_failures().</p>
<p>Note that for primary key fields (but not data fields) with no explicit data type, a temporary filter
 that excludes only Null will be applied. If you want primary key fields to allow Null, you must explicitly
 opt-in by calling set_data_type appropriately.
 See issue https://github.com/ticdat/ticdat/issues/46 for more info.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.find_foreign_key_failures">find_foreign_key_failures</h1>

<pre><code class="python">TicDatFactory.find_foreign_key_failures(self, tic_dat, verbosity='High', max_failures=inf)
</code></pre>

<p>Finds the foreign key failures for a ticdat object</p>
<p>:param tic_dat: ticdat object</p>
<p>:param max_failures: number. An upper limit on the number of failures to find. Will short circuit and return
                             ASAP with a partial failure enumeration when this number is reached.</p>
<p>:param verbosity: either "High" or "Low"</p>
<p>:return: A dictionary constructed as follow (for verbosity = 'High'):</p>
<p>The keys are namedtuples with members "native_table", "foreign_table",
 "mapping", "cardinality".</p>
<p>The key data matches the arguments to add_foreign_key that constructed the
 foreign key (with "cardinality" being deduced from the overall schema).</p>
<p>The values are namedtuples with the following members.</p>
<p>--&gt; native_values - the values of the native fields that failed to match</p>
<p>--&gt; native_pks - the primary key entries of the native table rows
                  corresponding to the native_values.</p>
<p>That is to say, native_values tells you which values in the native table
 can't find a foreign key match, and thus generate a foreign key failure.
 native_pks tells you which native table rows will be removed if you call
 remove_foreign_key_failures().</p>
<p>For verbosity = 'Low' a simpler return object is created that doesn't use namedtuples
 and omits the foreign key cardinality.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.freeze_me">freeze_me</h1>

<pre><code class="python">TicDatFactory.freeze_me(self, tic_dat)
</code></pre>

<p>Freezes a ticdat object</p>
<p>:param tic_dat: ticdat object</p>
<p>:return: tic_dat, after it has been frozen</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.good_tic_dat_object">good_tic_dat_object</h1>

<pre><code class="python">TicDatFactory.good_tic_dat_object(self, data_obj, bad_message_handler=&lt;function TicDatFactory.&lt;lambda&gt; at 0x11be52268&gt;, row_checking='strict')
</code></pre>

<p>determines if an object can be can be converted to a TicDat data object.</p>
<p>:param data_obj: the object to verify</p>
<p>:param bad_message_handler: a call back function to receive description of any failure message</p>
<p>:param row_checking: either "generous" or "strict". If the latter, then we expect all the rows to be dicts
                     with the correct columns (except for things like generic tables)
                     defaults to strict since this is the protector for the solve functions</p>
<p>:return: True if the dataObj can be converted to a TicDat data object. False otherwise.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.good_tic_dat_table">good_tic_dat_table</h1>

<pre><code class="python">TicDatFactory.good_tic_dat_table(self, data_table, table_name, bad_message_handler=&lt;function TicDatFactory.&lt;lambda&gt; at 0x11be52488&gt;, row_checking='generous')
</code></pre>

<p>determines if an object can be can be converted to a TicDat data table.</p>
<p>:param dataObj: the object to verify</p>
<p>:param table_name: the name of the table</p>
<p>:param bad_message_handler: a call back function to receive
       description of any failure message</p>
<p>:param row_checking: either "generous" or "strict". If the latter, then we expect all the rows to be dicts
                     with the correct columns (except for things like generic tables)
                     defaults to generous since this gets used a lot internally</p>
<p>:return: True if the dataObj can be converted to a TicDat
         data table. False otherwise.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.obfusimplify">obfusimplify</h1>

<pre><code class="python">TicDatFactory.obfusimplify(self, tic_dat, table_prepends={}, skip_tables=(), freeze_it=False)
</code></pre>

<p>copies the tic_dat object into a new, obfuscated, simplified tic_dat object</p>
<p>:param tic_dat: a ticdat object</p>
<p>:param table_prepends: a dictionary with mapping each table to the prepend it should apply
                       when its entries are renamed.  A valid table prepend must be all caps and
                       not end with I. Should be restricted to entity tables (single field primary
                       that is not a foreign key child)</p>
<p>:param skip_tables: a listing of entity tables whose single field primary key shouldn't be renamed</p>
<p>:param freeze_it: boolean. should the returned copy be frozen?</p>
<p>:return: A named tuple with the following components.</p>
<p>copy : a deep copy of the tic_dat argument, with the single field primary key values
        renamed to simple "short capital letters followed by numbers" strings.</p>
<p>renamings : a dictionary matching the new entries to their original (table, primary key value)
             this entry can be used to cross reference any diagnostic information gleaned from the
             obfusimplified copy to the original names. For example, "P5 has no production"
             can easily be recognized as "Product KX12212 has no production".</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.remove_foreign_key_failures">remove_foreign_key_failures</h1>

<pre><code class="python">TicDatFactory.remove_foreign_key_failures(self, tic_dat, propagate=True)
</code></pre>

<p>Removes foreign key failures (i.e. child records with no parent table record)</p>
<p>:param tic_dat: ticdat object</p>
<p>:param propagate boolean: remove cascading failures? (if removing the child record
                          results in new failures, should those be removed as well?)</p>
<p>:return: tic_dat, with the foreign key failures removed</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.replace_data_type_failures">replace_data_type_failures</h1>

<pre><code class="python">TicDatFactory.replace_data_type_failures(self, tic_dat, replacement_values={})
</code></pre>

<p>Replace the data cells with data type failures with the default value for the appropriate field.</p>
<p>:param tic_dat: a TicDat object appropriate for this schema</p>
<p>:param replacement_values: a dictionary mapping (table, field) to replacement value.
       the default value will be used for (table, field) pairs not in replacement_values</p>
<p>:return: the tic_dat object with replacements made. The tic_dat object itself will be edited in place.</p>
<p>Replaces any of the data failures found in find_data_type_failures() with the appropriate
replacement_value.</p>
<p>Note - won't perform primary key replacements.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.schema">schema</h1>

<pre><code class="python">TicDatFactory.schema(self, include_ancillary_info=False)
</code></pre>

<p>:param include_ancillary_info: if True, include all the foreign key, default, and data type information
                               as well. Otherwise, just return table-fields dictionary</p>
<p>:return: a dictionary with table name mapping to a list of lists
         defining primary key fields and data fields
         If include_ancillary_info, this table-fields dictionary is just one entry in a more comprehensive
         dictionary.</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.set_ampl_data">set_ampl_data</h1>

<pre><code class="python">TicDatFactory.set_ampl_data(self, tic_dat, ampl, table_to_set_name=None)
</code></pre>

<p>performs bulk setData on the AMPL first argument.</p>
<p>:param tic_dat: an AmplTicDat object created by calling copy_to_ampl</p>
<p>:param ampl: an amplpy.AMPL object</p>
<p>:param table_to_set_name: a mapping of table_name to ampl set name
:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.set_data_type">set_data_type</h1>

<pre><code class="python">TicDatFactory.set_data_type(self, table, field, number_allowed=True, inclusive_min=True, inclusive_max=False, min=0, max=inf, must_be_int=False, strings_allowed=(), nullable=False, datetime=False)
</code></pre>

<p>sets the data type for a field. By default, fields don't have types. Adding a data type doesn't block
data of the wrong type from being entered. Data types are useful for recognizing errant data entries
with find_data_type_failures(). Errant data entries can be replaced with replace_data_type_failures().</p>
<p>:param table: a table in the schema</p>
<p>:param field: a field for this table</p>
<p>:param number_allowed: boolean does this field allow numbers?</p>
<p>:param inclusive_min: boolean : if number allowed, is the min inclusive?</p>
<p>:param inclusive_max: boolean : if number allowed, is the max inclusive?</p>
<p>:param min: if number allowed, the minimum value</p>
<p>:param max: if number allowed, the maximum value</p>
<p>:param must_be_int: boolean : if number allowed, must the number be integral?</p>
<p>:param strings_allowed: if a collection - then a list of the strings allowed.
                        The empty collection prohibits strings.
                        If a "*", then any string is accepted.</p>
<p>:param nullable : boolean : can this value contain null (aka None)</p>
<p>:param datetime: If truthy, then number_allowed through strings_allowed are ignored. Should the data either
                 be a datetime.datetime object or a string that can be parsed into a datetime.datetime object?
                 Note that the various readers will try to coerce strings into datetime.datetime objects
                 on read for fields with datetime data types. pandas.Timestamp is itself a datetime.datetime,
                 and the bias will be to create such an object.
:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.set_default_value">set_default_value</h1>

<pre><code class="python">TicDatFactory.set_default_value(self, table, field, default_value)
</code></pre>

<p>sets the default value for a specific field</p>
<p>:param table: a table in the schema</p>
<p>:param field: a field in the table</p>
<p>:param default_value: the default value to apply</p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.set_default_values">set_default_values</h1>

<pre><code class="python">TicDatFactory.set_default_values(self, **tableDefaults)
</code></pre>

<p>sets the default values for the fields</p>
<p>:param tableDefaults:
     A dictionary of named arguments. Each argument name (i.e. each key) should be a table name
     Each value should itself be a dictionary mapping data field names to default values</p>
<p>Ex:
<code>tdf.set_default_values(categories = {"minNutrition":0, "maxNutrition":float("inf")},
                          foods = {"cost":0}, nutritionQuantities = {"qty":0})</code></p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.set_generator_tables">set_generator_tables</h1>

<pre><code class="python">TicDatFactory.set_generator_tables(self, g)
</code></pre>

<p>sets which tables are to be generator tables. Generator tables are represented as generators
pulled from the actual data store. This prevents them from being fulled loaded into memory.
Generator tables are only appropriate for truly massive data tables with no primary key.</p>
<p>:param g: An iterable of table name.</p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.TicDatFactory.set_infinity_io_flag">set_infinity_io_flag</h1>

<pre><code class="python">TicDatFactory.set_infinity_io_flag(self, value)
</code></pre>

<p>Set the infinity_io_flag for the TicDatFactory.
'N/A' (the default) is recognized as a flag to disable infinity I/O buffering.</p>
<p>If numeric, when writing data to the file system (or a database), float("inf") will be replaced by the
infinity_io_flag and float("-inf") will be replaced by -infinity_io_flag, prior to writing.
Similarly, the read data will replace any number &gt;= the infinity_io_flag with float("inf") and any
number smaller than float("-inf") with -infinity_io_flag.</p>
<p>If None, then +/- infinity will be replaced by None prior to writing.
Similarly, subsequent to reading, None will be replaced either by float("inf") or float("-inf"), depending
on field data types.
Note that None flagging will only perform replacements on fields whose data types allow infinity and not None.</p>
<p>For all cases, these replacements will be done on a temporary copy of the data that is created prior to writing.</p>
<p>Also note that none of the these replacements will be done on the parameters table. The assumption is the
parameters table will be serialized to a string/string database table. Infinity can thus be represented by
"inf"/"-inf" in such serializations. File readers will attempt to cast strings to floats on a row-by-row
basis, as determined by add_parameter settings. File writers will cast parameters table entries to strings
(assuming the add_parameters functionality is being used).</p>
<p>:param value: a valid infinity_io_flag</p>
<p>:return:</p>
<h1 id="ticdat.ticdatfactory.freeze_me">freeze_me</h1>

<pre><code class="python">freeze_me(x)
</code></pre>

<p>Freezes a ticdat object</p>
<p>:param x: ticdat object</p>
<p>:return: x, after it has been frozen</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../csvtd/" class="btn btn-neutral float-right" title="CsvTicFactory">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../pandatio/" class="btn btn-neutral" title="XlsPanFactory"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/ticdat/ticdat/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../pandatio/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../csvtd/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
